#!/usr/bin/env sh
. "$(dirname -- "$0")/_/husky.sh"

echo "ğŸš€ Executando verificaÃ§Ãµes prÃ©-push..."

# Verificar se estamos na branch correta
branch_atual=$(git branch --show-current)
echo "ğŸ“‹ Branch atual: $branch_atual"

# Evitar push direto para main/master
if [ "$branch_atual" = "main" ] || [ "$branch_atual" = "master" ]; then
    echo "âš ï¸ Push direto para $branch_atual detectado"
    read -p "Tem certeza que deseja fazer push para $branch_atual? (s/N): " confirmacao
    if [ "$confirmacao" != "s" ] && [ "$confirmacao" != "S" ]; then
        echo "âŒ Push cancelado pelo usuÃ¡rio"
        exit 1
    fi
fi

# Verificar se hÃ¡ testes (se existirem)
if [ -f "tests.py" ] || [ -f "test_*.py" ] || [ -d "tests/" ]; then
    echo "ğŸ§ª Executando testes..."
    
    if command -v pytest >/dev/null 2>&1; then
        pytest --tb=short
        if [ $? -ne 0 ]; then
            echo "âŒ Testes falharam. Push cancelado."
            exit 1
        fi
    elif command -v python >/dev/null 2>&1; then
        # Tentar executar testes com unittest
        if [ -f "tests.py" ]; then
            python -m unittest tests.py
            if [ $? -ne 0 ]; then
                echo "âŒ Testes falharam. Push cancelado."
                exit 1
            fi
        fi
    fi
fi

# Verificar se requirements.txt estÃ¡ atualizado
if [ -f "requirements.txt" ]; then
    echo "ğŸ“¦ Verificando dependÃªncias..."
    
    # Verificar se hÃ¡ mudanÃ§as nÃ£o commitadas no requirements.txt
    if git status --porcelain | grep "requirements.txt"; then
        echo "âš ï¸ requirements.txt tem mudanÃ§as nÃ£o commitadas"
        echo "   Considere commitar as mudanÃ§as antes do push"
    fi
    
    # Verificar se hÃ¡ imports nÃ£o listados (verificaÃ§Ã£o bÃ¡sica)
    if command -v python >/dev/null 2>&1; then
        echo "ğŸ” Verificando imports vs requirements..."
        # Esta Ã© uma verificaÃ§Ã£o simplificada
        python -c "
import ast
import sys
import os

# Coletar imports do app.py
imports = set()
if os.path.exists('app.py'):
    with open('app.py', 'r', encoding='utf-8') as f:
        try:
            tree = ast.parse(f.read())
            for node in ast.walk(tree):
                if isinstance(node, ast.Import):
                    for alias in node.names:
                        imports.add(alias.name.split('.')[0])
                elif isinstance(node, ast.ImportFrom):
                    if node.module:
                        imports.add(node.module.split('.')[0])
        except:
            pass

# Filtrar imports padrÃ£o
stdlib_modules = {
    'os', 'sys', 'json', 'time', 'datetime', 'hashlib', 'uuid', 'io', 
    'pathlib', 'shutil', 're', 'random', 'asyncio'
}
external_imports = imports - stdlib_modules

# Ler requirements.txt
requirements = set()
if os.path.exists('requirements.txt'):
    with open('requirements.txt', 'r') as f:
        for line in f:
            if line.strip() and not line.startswith('#'):
                pkg = line.strip().split('==')[0].split('>=')[0].split('<=')[0]
                requirements.add(pkg.lower())

# Verificar discrepÃ¢ncias
missing = external_imports - requirements
if missing:
    print(f'âš ï¸ Imports possivelmente nÃ£o listados em requirements.txt: {missing}')
"
    fi
fi

# Verificar se hÃ¡ arquivos grandes nÃ£o rastreados
echo "ğŸ“ Verificando arquivos grandes..."
find . -type f -size +10M -not -path "./.git/*" -not -path "./venv/*" -not -path "./__pycache__/*" | while read arquivo; do
    if ! git check-ignore "$arquivo" >/dev/null 2>&1; then
        echo "âš ï¸ Arquivo grande nÃ£o ignorado: $arquivo"
        echo "   Considere adicionar ao .gitignore ou usar Git LFS"
    fi
done

# Verificar por arquivos temporÃ¡rios
echo "ğŸ§¹ Verificando arquivos temporÃ¡rios..."
arquivos_temp=$(find . -name "*.tmp" -o -name "*.log" -o -name "*.cache" -o -name "__pycache__" -o -name "*.pyc" | grep -v ".git")
if [ ! -z "$arquivos_temp" ]; then
    echo "âš ï¸ Arquivos temporÃ¡rios detectados:"
    echo "$arquivos_temp"
    echo "   Considere adicionar ao .gitignore"
fi

# Verificar configuraÃ§Ãµes de seguranÃ§a
echo "ğŸ”’ Verificando configuraÃ§Ãµes de seguranÃ§a..."

# Verificar se hÃ¡ arquivos de configuraÃ§Ã£o com dados sensÃ­veis
for arquivo in $(find . -name "config.py" -o -name "settings.py" -o -name ".env*" -o -name "secrets.toml"); do
    if [ -f "$arquivo" ] && ! git check-ignore "$arquivo" >/dev/null 2>&1; then
        echo "âš ï¸ Arquivo de configuraÃ§Ã£o detectado: $arquivo"
        echo "   Verifique se nÃ£o contÃ©m dados sensÃ­veis"
    fi
done

# Verificar integridade bÃ¡sica do projeto
echo "ğŸ” Verificando integridade do projeto..."

# Verificar se app.py existe e Ã© vÃ¡lido
if [ -f "app.py" ]; then
    if command -v python >/dev/null 2>&1; then
        python -m py_compile app.py
        if [ $? -ne 0 ]; then
            echo "âŒ app.py contÃ©m erros de sintaxe"
            exit 1
        fi
    fi
else
    echo "âš ï¸ app.py nÃ£o encontrado"
fi

# Verificar se hÃ¡ conflitos de merge nÃ£o resolvidos
if git ls-files -u | grep -q .; then
    echo "âŒ Conflitos de merge nÃ£o resolvidos detectados"
    exit 1
fi

# EstatÃ­sticas do push
echo "ğŸ“Š EstatÃ­sticas do push:"
commits_count=$(git rev-list --count HEAD ^@{u} 2>/dev/null || echo "0")
echo "   ğŸ“ Commits: $commits_count"

arquivos_modificados=$(git diff --name-only @{u}..HEAD 2>/dev/null | wc -l || echo "0")
echo "   ğŸ“ Arquivos modificados: $arquivos_modificados"

# VerificaÃ§Ã£o final
echo "âœ… Todas as verificaÃ§Ãµes prÃ©-push foram concluÃ­das!"
echo "ğŸš€ Prosseguindo com o push..."
