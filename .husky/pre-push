#!/usr/bin/env sh
. "$(dirname -- "$0")/_/husky.sh"

echo "🚀 Executando verificações pré-push..."

# Verificar se estamos na branch correta
branch_atual=$(git branch --show-current)
echo "📋 Branch atual: $branch_atual"

# Evitar push direto para main/master
if [ "$branch_atual" = "main" ] || [ "$branch_atual" = "master" ]; then
    echo "⚠️ Push direto para $branch_atual detectado"
    read -p "Tem certeza que deseja fazer push para $branch_atual? (s/N): " confirmacao
    if [ "$confirmacao" != "s" ] && [ "$confirmacao" != "S" ]; then
        echo "❌ Push cancelado pelo usuário"
        exit 1
    fi
fi

# Verificar se há testes (se existirem)
if [ -f "tests.py" ] || [ -f "test_*.py" ] || [ -d "tests/" ]; then
    echo "🧪 Executando testes..."
    
    if command -v pytest >/dev/null 2>&1; then
        pytest --tb=short
        if [ $? -ne 0 ]; then
            echo "❌ Testes falharam. Push cancelado."
            exit 1
        fi
    elif command -v python >/dev/null 2>&1; then
        # Tentar executar testes com unittest
        if [ -f "tests.py" ]; then
            python -m unittest tests.py
            if [ $? -ne 0 ]; then
                echo "❌ Testes falharam. Push cancelado."
                exit 1
            fi
        fi
    fi
fi

# Verificar se requirements.txt está atualizado
if [ -f "requirements.txt" ]; then
    echo "📦 Verificando dependências..."
    
    # Verificar se há mudanças não commitadas no requirements.txt
    if git status --porcelain | grep "requirements.txt"; then
        echo "⚠️ requirements.txt tem mudanças não commitadas"
        echo "   Considere commitar as mudanças antes do push"
    fi
    
    # Verificar se há imports não listados (verificação básica)
    if command -v python >/dev/null 2>&1; then
        echo "🔍 Verificando imports vs requirements..."
        # Esta é uma verificação simplificada
        python -c "
import ast
import sys
import os

# Coletar imports do app.py
imports = set()
if os.path.exists('app.py'):
    with open('app.py', 'r', encoding='utf-8') as f:
        try:
            tree = ast.parse(f.read())
            for node in ast.walk(tree):
                if isinstance(node, ast.Import):
                    for alias in node.names:
                        imports.add(alias.name.split('.')[0])
                elif isinstance(node, ast.ImportFrom):
                    if node.module:
                        imports.add(node.module.split('.')[0])
        except:
            pass

# Filtrar imports padrão
stdlib_modules = {
    'os', 'sys', 'json', 'time', 'datetime', 'hashlib', 'uuid', 'io', 
    'pathlib', 'shutil', 're', 'random', 'asyncio'
}
external_imports = imports - stdlib_modules

# Ler requirements.txt
requirements = set()
if os.path.exists('requirements.txt'):
    with open('requirements.txt', 'r') as f:
        for line in f:
            if line.strip() and not line.startswith('#'):
                pkg = line.strip().split('==')[0].split('>=')[0].split('<=')[0]
                requirements.add(pkg.lower())

# Verificar discrepâncias
missing = external_imports - requirements
if missing:
    print(f'⚠️ Imports possivelmente não listados em requirements.txt: {missing}')
"
    fi
fi

# Verificar se há arquivos grandes não rastreados
echo "📁 Verificando arquivos grandes..."
find . -type f -size +10M -not -path "./.git/*" -not -path "./venv/*" -not -path "./__pycache__/*" | while read arquivo; do
    if ! git check-ignore "$arquivo" >/dev/null 2>&1; then
        echo "⚠️ Arquivo grande não ignorado: $arquivo"
        echo "   Considere adicionar ao .gitignore ou usar Git LFS"
    fi
done

# Verificar por arquivos temporários
echo "🧹 Verificando arquivos temporários..."
arquivos_temp=$(find . -name "*.tmp" -o -name "*.log" -o -name "*.cache" -o -name "__pycache__" -o -name "*.pyc" | grep -v ".git")
if [ ! -z "$arquivos_temp" ]; then
    echo "⚠️ Arquivos temporários detectados:"
    echo "$arquivos_temp"
    echo "   Considere adicionar ao .gitignore"
fi

# Verificar configurações de segurança
echo "🔒 Verificando configurações de segurança..."

# Verificar se há arquivos de configuração com dados sensíveis
for arquivo in $(find . -name "config.py" -o -name "settings.py" -o -name ".env*" -o -name "secrets.toml"); do
    if [ -f "$arquivo" ] && ! git check-ignore "$arquivo" >/dev/null 2>&1; then
        echo "⚠️ Arquivo de configuração detectado: $arquivo"
        echo "   Verifique se não contém dados sensíveis"
    fi
done

# Verificar integridade básica do projeto
echo "🔍 Verificando integridade do projeto..."

# Verificar se app.py existe e é válido
if [ -f "app.py" ]; then
    if command -v python >/dev/null 2>&1; then
        python -m py_compile app.py
        if [ $? -ne 0 ]; then
            echo "❌ app.py contém erros de sintaxe"
            exit 1
        fi
    fi
else
    echo "⚠️ app.py não encontrado"
fi

# Verificar se há conflitos de merge não resolvidos
if git ls-files -u | grep -q .; then
    echo "❌ Conflitos de merge não resolvidos detectados"
    exit 1
fi

# Estatísticas do push
echo "📊 Estatísticas do push:"
commits_count=$(git rev-list --count HEAD ^@{u} 2>/dev/null || echo "0")
echo "   📝 Commits: $commits_count"

arquivos_modificados=$(git diff --name-only @{u}..HEAD 2>/dev/null | wc -l || echo "0")
echo "   📁 Arquivos modificados: $arquivos_modificados"

# Verificação final
echo "✅ Todas as verificações pré-push foram concluídas!"
echo "🚀 Prosseguindo com o push..."
