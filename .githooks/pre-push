#!/bin/bash
# Hook pre-push para PetCare DBA Admin
# Este script Ã© executado antes de fazer push para garantir qualidade e seguranÃ§a

set -e

# Cores para output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
NC='\033[0m' # No Color

# ConfiguraÃ§Ãµes
REMOTE_NAME=$1
REMOTE_URL=$2
MAIN_BRANCH="main"
DEVELOP_BRANCH="develop"

echo -e "${BLUE}ğŸš€ Executando verificaÃ§Ãµes pre-push para ${REMOTE_NAME}...${NC}"

# FunÃ§Ã£o para imprimir cabeÃ§alho de seÃ§Ã£o
print_section() {
    echo -e "\n${BLUE}â•â•â• $1 â•â•â•${NC}"
}

# FunÃ§Ã£o para verificar se comando existe
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

# Obter branch atual
current_branch=$(git symbolic-ref --short HEAD)
echo -e "${PURPLE}ğŸ“ Branch atual: ${current_branch}${NC}"

# Obter commits que serÃ£o enviados
commits_to_push=$(git rev-list ${REMOTE_NAME}/${current_branch}..HEAD 2>/dev/null || git rev-list HEAD --not --remotes 2>/dev/null || echo "")
commit_count=$(echo "$commits_to_push" | grep -v '^$' | wc -l || echo "0")

echo -e "${YELLOW}ğŸ“¦ Commits a serem enviados: ${commit_count}${NC}"

if [ "$commit_count" -eq 0 ]; then
    echo -e "${GREEN}âœ… Nenhum commit novo para enviar${NC}"
    exit 0
fi

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# 1. VERIFICAÃ‡ÃƒO DE BRANCH PROTEGIDA
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
print_section "VerificaÃ§Ã£o de Branch Protegida"

if [ "$current_branch" = "$MAIN_BRANCH" ]; then
    echo -e "${RED}âŒ Push direto para $MAIN_BRANCH nÃ£o Ã© permitido!${NC}"
    echo -e "${BLUE}ğŸ’¡ Use Pull Request para enviar mudanÃ§as para $MAIN_BRANCH${NC}"
    exit 1
elif [ "$current_branch" = "$DEVELOP_BRANCH" ]; then
    echo -e "${YELLOW}âš ï¸  Enviando para $DEVELOP_BRANCH. Certifique-se de que os testes passaram.${NC}"
    read -p "Continuar? [y/N] " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        echo -e "${BLUE}Push cancelado pelo usuÃ¡rio${NC}"
        exit 1
    fi
else
    echo -e "${GREEN}âœ… Branch ${current_branch} permitida para push${NC}"
fi

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# 2. VERIFICAÃ‡ÃƒO DE COMMITS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
print_section "VerificaÃ§Ã£o de Commits"

echo "  Analisando commits que serÃ£o enviados..."

# Verificar mensagens de commit
invalid_commits=0
for commit in $commits_to_push; do
    if [ -n "$commit" ]; then
        commit_msg=$(git log --format=%s -n 1 "$commit")
        commit_short=$(echo "$commit" | cut -c1-8)
        
        echo "    $commit_short: $commit_msg"
        
        # Verificar se mensagem segue padrÃ£o mÃ­nimo
        if [ ${#commit_msg} -lt 10 ]; then
            echo -e "      ${RED}âŒ Mensagem muito curta${NC}"
            invalid_commits=$((invalid_commits + 1))
        fi
        
        # Verificar padrÃµes problemÃ¡ticos
        if echo "$commit_msg" | grep -qE "^(WIP|TODO|FIXME|DEBUG|TEST)"; then
            echo -e "      ${YELLOW}âš ï¸  Commit parece temporÃ¡rio${NC}"
        fi
        
        if echo "$commit_msg" | grep -qE "^fix|Fix"; then
            echo -e "      ${BLUE}ğŸ”§ Commit de correÃ§Ã£o${NC}"
        fi
    fi
done

if [ $invalid_commits -gt 0 ]; then
    echo -e "${RED}âŒ $invalid_commits commit(s) com mensagens inadequadas${NC}"
    echo -e "${BLUE}ğŸ’¡ Use 'git rebase -i' para melhorar as mensagens${NC}"
    exit 1
fi

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# 3. EXECUÃ‡ÃƒO DE TESTES
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
print_section "ExecuÃ§Ã£o de Testes"

if [ -f "requirements.txt" ] && command_exists python3; then
    echo "  Verificando se pytest estÃ¡ disponÃ­vel..."
    
    if command_exists pytest; then
        echo "  Executando testes..."
        
        # Executar testes com timeout
        timeout 300s pytest tests/ -v --tb=short || {
            test_exit_code=$?
            echo -e "${RED}âŒ Testes falharam (cÃ³digo: $test_exit_code)${NC}"
            
            if [ $test_exit_code -eq 124 ]; then
                echo -e "${YELLOW}âš ï¸  Testes interrompidos por timeout (5 min)${NC}"
            fi
            
            read -p "Continuar mesmo assim? [y/N] " -n 1 -r
            echo
            if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                exit 1
            fi
        }
        
        echo -e "  ${GREEN}âœ… Testes passaram${NC}"
    else
        echo -e "  ${YELLOW}âš ï¸  Pytest nÃ£o instalado. Pulando testes.${NC}"
    fi
else
    echo -e "  ${YELLOW}âš ï¸  Ambiente Python nÃ£o configurado. Pulando testes.${NC}"
fi

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# 4. VERIFICAÃ‡ÃƒO DE DEPENDÃŠNCIAS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
print_section "VerificaÃ§Ã£o de DependÃªncias"

if [ -f "requirements.txt" ]; then
    echo "  Verificando dependÃªncias..."
    
    # Verificar se hÃ¡ dependÃªncias com versÃµes nÃ£o especificadas
    unpinned_deps=$(grep -v "==" requirements.txt | grep -v "^#" | grep -v "^$" || true)
    if [ -n "$unpinned_deps" ]; then
        echo -e "  ${YELLOW}âš ï¸  DependÃªncias sem versÃ£o especÃ­fica encontradas:${NC}"
        echo "$unpinned_deps" | sed 's/^/    /'
    fi
    
    # Verificar vulnerabilidades se safety estiver disponÃ­vel
    if command_exists safety; then
        echo "  Verificando vulnerabilidades de seguranÃ§a..."
        if safety check --json >/dev/null 2>&1; then
            echo -e "  ${GREEN}âœ… Nenhuma vulnerabilidade conhecida${NC}"
        else
            echo -e "  ${YELLOW}âš ï¸  PossÃ­veis vulnerabilidades encontradas${NC}"
            echo -e "  ${BLUE}ğŸ’¡ Execute: safety check --full-report${NC}"
        fi
    fi
    
    echo -e "  ${GREEN}âœ… VerificaÃ§Ã£o de dependÃªncias concluÃ­da${NC}"
else
    echo -e "  ${YELLOW}âš ï¸  requirements.txt nÃ£o encontrado${NC}"
fi

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# 5. VERIFICAÃ‡ÃƒO DE ARQUIVOS GRANDES
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
print_section "VerificaÃ§Ã£o de Arquivos Grandes"

# Verificar se hÃ¡ arquivos grandes nos commits
large_files_found=0
MAX_SIZE=$((10 * 1024 * 1024)) # 10MB

for commit in $commits_to_push; do
    if [ -n "$commit" ]; then
        files_in_commit=$(git diff-tree --no-commit-id --name-only -r "$commit")
        for file in $files_in_commit; do
            if [ -f "$file" ]; then
                size=$(stat -c%s "$file" 2>/dev/null || stat -f%z "$file" 2>/dev/null || echo 0)
                if [ "$size" -gt $MAX_SIZE ]; then
                    echo -e "  ${RED}âŒ Arquivo grande: $file ($(($size / 1024 / 1024))MB)${NC}"
                    large_files_found=1
                fi
            fi
        done
    fi
done

if [ $large_files_found -eq 1 ]; then
    echo -e "  ${RED}âŒ Arquivos grandes detectados no push${NC}"
    echo -e "  ${BLUE}ğŸ’¡ Considere usar Git LFS para arquivos grandes${NC}"
    
    read -p "Continuar mesmo assim? [y/N] " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        exit 1
    fi
else
    echo -e "  ${GREEN}âœ… Nenhum arquivo grande detectado${NC}"
fi

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# 6. VERIFICAÃ‡ÃƒO DE MERGE CONFLICTS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
print_section "VerificaÃ§Ã£o de Merge Conflicts"

conflict_markers_found=0
for commit in $commits_to_push; do
    if [ -n "$commit" ]; then
        files_in_commit=$(git diff-tree --no-commit-id --name-only -r "$commit")
        for file in $files_in_commit; do
            if [ -f "$file" ] && grep -l "^<<<<<<< \|^======= \|^>>>>>>> " "$file" >/dev/null 2>&1; then
                echo -e "  ${RED}âŒ Marcadores de merge conflict em: $file${NC}"
                conflict_markers_found=1
            fi
        done
    fi
done

if [ $conflict_markers_found -eq 1 ]; then
    echo -e "  ${RED}âŒ Marcadores de merge conflict detectados${NC}"
    echo -e "  ${BLUE}ğŸ’¡ Resolva os conflicts antes de fazer push${NC}"
    exit 1
else
    echo -e "  ${GREEN}âœ… Nenhum merge conflict detectado${NC}"
fi

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# 7. VERIFICAÃ‡ÃƒO DE TODO/FIXME
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
print_section "VerificaÃ§Ã£o de TODOs e FIXMEs"

todo_count=0
fixme_count=0

for commit in $commits_to_push; do
    if [ -n "$commit" ]; then
        files_in_commit=$(git diff-tree --no-commit-id --name-only -r "$commit")
        for file in $files_in_commit; do
            if [ -f "$file" ]; then
                todos=$(grep -n "TODO\|FIXME\|XXX\|HACK" "$file" || true)
                if [ -n "$todos" ]; then
                    todo_count=$((todo_count + 1))
                    echo "  ğŸ“ TODOs em $file:"
                    echo "$todos" | sed 's/^/    /'
                fi
            fi
        done
    fi
done

if [ $todo_count -gt 5 ]; then
    echo -e "  ${YELLOW}âš ï¸  Muitos TODOs/FIXMEs encontrados ($todo_count)${NC}"
    echo -e "  ${BLUE}ğŸ’¡ Considere resolver alguns antes do push${NC}"
else
    echo -e "  ${GREEN}âœ… Quantidade de TODOs aceitÃ¡vel${NC}"
fi

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# 8. VERIFICAÃ‡ÃƒO DE SECRETS/CREDENCIAIS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
print_section "VerificaÃ§Ã£o de Secrets"

secrets_found=0
SECRET_PATTERNS=(
    "password\s*=\s*['\"][^'\"]*['\"]"
    "secret\s*=\s*['\"][^'\"]*['\"]"
    "api_key\s*=\s*['\"][^'\"]*['\"]"
    "token\s*=\s*['\"][^'\"]*['\"]"
    "BEGIN PRIVATE KEY"
    "BEGIN RSA PRIVATE KEY"
    "ssh-rsa"
    "ssh-dss"
)

for commit in $commits_to_push; do
    if [ -n "$commit" ]; then
        # Verificar diff do commit por padrÃµes sensÃ­veis
        for pattern in "${SECRET_PATTERNS[@]}"; do
            matches=$(git show "$commit" | grep -E "$pattern" || true)
            if [ -n "$matches" ]; then
                echo -e "  ${RED}âŒ PossÃ­vel secret detectado no commit $commit:${NC}"
                echo "$matches" | sed 's/^/    /' | head -3
                secrets_found=1
            fi
        done
    fi
done

if [ $secrets_found -eq 1 ]; then
    echo -e "  ${RED}âŒ PossÃ­veis secrets detectados!${NC}"
    echo -e "  ${BLUE}ğŸ’¡ Remova credenciais e use variÃ¡veis de ambiente${NC}"
    exit 1
else
    echo -e "  ${GREEN}âœ… Nenhum secret detectado${NC}"
fi

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# 9. VERIFICAÃ‡ÃƒO DE PERFORMANCE
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
print_section "VerificaÃ§Ã£o de Performance"

if [ -f "app.py" ]; then
    echo "  Verificando padrÃµes que podem afetar performance..."
    
    # Verificar imports desnecessÃ¡rios
    heavy_imports=$(grep -n "import pandas\|import numpy\|import matplotlib" app.py || true)
    if [ -n "$heavy_imports" ]; then
        echo -e "  ${YELLOW}âš ï¸  Imports pesados encontrados:${NC}"
        echo "$heavy_imports" | sed 's/^/    /' | head -3
    fi
    
    # Verificar loops potencialmente problemÃ¡ticos
    nested_loops=$(grep -n "for.*for\|while.*while" app.py || true)
    if [ -n "$nested_loops" ]; then
        echo -e "  ${YELLOW}âš ï¸  Loops aninhados encontrados - verifique performance${NC}"
    fi
    
    echo -e "  ${GREEN}âœ… VerificaÃ§Ã£o de performance concluÃ­da${NC}"
fi

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# 10. VERIFICAÃ‡ÃƒO DE DOCUMENTAÃ‡ÃƒO
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
print_section "VerificaÃ§Ã£o de DocumentaÃ§Ã£o"

# Verificar se README foi atualizado quando necessÃ¡rio
if echo "$commits_to_push" | xargs git diff-tree --no-commit-id --name-only -r | grep -q "app.py\|requirements.txt"; then
    if ! echo "$commits_to_push" | xargs git diff-tree --no-commit-id --name-only -r | grep -q "README.md"; then
        echo -e "  ${YELLOW}âš ï¸  MudanÃ§as significativas sem atualizaÃ§Ã£o do README${NC}"
        echo -e "  ${BLUE}ğŸ’¡ Considere atualizar a documentaÃ§Ã£o${NC}"
    fi
fi

# Verificar se CHANGELOG foi atualizado para releases
if [ "$current_branch" = "$DEVELOP_BRANCH" ] || echo "$current_branch" | grep -q "release/"; then
    if ! echo "$commits_to_push" | xargs git diff-tree --no-commit-id --name-only -r | grep -q "CHANGELOG"; then
        echo -e "  ${YELLOW}âš ï¸  Branch de release sem atualizaÃ§Ã£o do CHANGELOG${NC}"
    fi
fi

echo -e "  ${GREEN}âœ… VerificaÃ§Ã£o de documentaÃ§Ã£o concluÃ­da${NC}"

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# 11. VERIFICAÃ‡ÃƒO FINAL E CONFIRMAÃ‡ÃƒO
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
print_section "ConfirmaÃ§Ã£o Final"

echo -e "${BLUE}ğŸ“Š Resumo do Push:${NC}"
echo "  â€¢ Branch: $current_branch"
echo "  â€¢ Remote: $REMOTE_NAME ($REMOTE_URL)"
echo "  â€¢ Commits: $commit_count"
echo "  â€¢ Arquivos modificados: $(echo "$commits_to_push" | xargs git diff-tree --no-commit-id --name-only -r 2>/dev/null | sort -u | wc -l)"

# Lista dos Ãºltimos commits
echo -e "\n${BLUE}ğŸ“ Ãšltimos commits:${NC}"
for commit in $(echo "$commits_to_push" | head -5); do
    if [ -n "$commit" ]; then
        commit_msg=$(git log --format="%h %s" -n 1 "$commit")
        echo "    $commit_msg"
    fi
done

if [ "$commit_count" -gt 5 ]; then
    echo "    ... e mais $(($commit_count - 5)) commit(s)"
fi

# VerificaÃ§Ã£o especial para branches principais
if [ "$current_branch" = "$DEVELOP_BRANCH" ] || echo "$current_branch" | grep -q "release/\|hotfix/"; then
    echo -e "\n${YELLOW}âš ï¸  ATENÃ‡ÃƒO: Push para branch importante ($current_branch)${NC}"
    echo -e "${BLUE}Certifique-se de que:${NC}"
    echo "  â€¢ Todos os testes passaram"
    echo "  â€¢ Code review foi realizado"
    echo "  â€¢ DocumentaÃ§Ã£o estÃ¡ atualizada"
    echo "  â€¢ NÃ£o hÃ¡ breaking changes sem aviso"
    
    read -p "Confirma o push? [y/N] " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        echo -e "${BLUE}Push cancelado pelo usuÃ¡rio${NC}"
        exit 1
    fi
fi

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CONCLUSÃƒO
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
echo -e "\n${GREEN}ğŸ‰ Todas as verificaÃ§Ãµes passaram! Push autorizado.${NC}"
echo -e "${BLUE}ğŸš€ Enviando $commit_count commit(s) para $REMOTE_NAME/$current_branch...${NC}"

exit 0
